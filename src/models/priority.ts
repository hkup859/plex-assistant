// const timestamps = require('mongoose-timestamp');
// const uuid = require('uuid')
const mongoose = require('mongoose')
const timestamps = require('mongoose-timestamp')

const PrioritySchema = new mongoose.Schema({
    title: {
        type: String,
        required: true,
    },
    year: {
        type: String,
        required: false, // TODO - Require if movie?, TV Shows will not have this
    },
    // resolution: { // Should this be the resolution we have or the resolution we look for? Meaning, we could just track the best resolution and always record a better one, or we could simply require a certain resolution. I lean more towards tracking current and getting what we can.
    //     type: String,
    //     required: false,
    // },
    mediaType: {
        type: String,
        required: true,
        enum: ['Movies', 'TV Shows'] // This is the terminology that Plex uses, but I would like to change to "Movie" & "TV Show", this however causes issues with some puppeteer sections that also use mediaType because they need exactly what Plex calls it.
    },
    shouldRecord: { // TODO - Set this to false when something is marked as recorded or detected as already being recorded
        type: Boolean,
        required: true,
    },
    lastAired: {
        type: Date,
        required: false // Optional field that allows tracking when the last instance of this media was aired (TV Show will need to choose the last episode instead of first)
    }
    // createdAt & updatedAt are automatically generated by the timestamps plugin
    // TODO - Add complex key -> title alone cannot be unique, but perhaps title with year if available or title with mediaType?
})

// createdAt & updatedAt are automatically generated by the timestamps plugin
PrioritySchema.plugin(timestamps);

// Create mongoose connection
const Priority = mongoose.connection.model('Priority', PrioritySchema);

export const createPriority = async (priorityObject: any): Promise<any> => {
  try {
        console.log('In Priority Model createPriority')
        const priority = new Priority(priorityObject)
        const newPriority = await priority.save()
        if (newPriority && newPriority._id)
            return newPriority
        else
            throw new Error("Failed to create priority record. No _id after attempting to save.")
  } catch (err) {
        console.log(`Fatal Error In Priority Model createPriority: ${err}`)
        throw err
  }
}

// TODO - Should this instead use save() so that timestamps work automatically? This adds inefficiency becase a find is required, but add timestamp simplicity.
export const updatePriority = async (_id, priorityUpdateObject): Promise<any> => {
    try {
        console.log('In Priority Model updatePriority')
        const updateQuery = {
            $set: {
                updatedAt: new Date(),
                ...priorityUpdateObject
            }
        }
        const updateResults = await Priority.updateOne({_id }, updateQuery)
        if (updateResults) // TODO - Provide optional return of the saved media object?
            return "success"
        else
            throw new Error("Failed to update priority record.")
    } catch (err) {
        console.log(`Fatal Error In Priority Model updatePriority: ${err}`)
        throw err
    }
}

export const findPriorityByTitleAndMediaType = async (title, mediaType): Promise<any> => {
    try {
        console.log('In Priority Model findPriorityByTitleAndMediaType')
        return await Priority.find({ title, mediaType })
        // // TODO - Confirm if this works, and should we use it?
        // return await Priority.find({title: { $regex: `/${title}/i` } })
    } catch (err) {
        console.log(`Fatal Error In Priority Model findPriorityByTitleAndMediaType: ${err}`)
        throw err
    }
}

// export const findAllUnprocessedMedia = async (): Promise<any> => {
//     try {
//         console.log('In Media Model findAllUnprocessedMedia')
//         return await Media.find({ rawData: { $exists: true }, error: false, title: { $exists: false }, year: { $exists: false }, length: { $exists: false }}) // TODO, add other fields & perhaps reprocess errors a certain number of times
//     } catch (err) {
//         console.log(`Fatal Error In Media Model findMedia: ${err}`)
//         throw err
//     }
// }

// export const testMedia = async (): Promise<any> => {
//     try {
//         console.log('In Media Model findAllUnprocessedMedia')
//         return await Media.find({ title: 'Larceny in Her Heart' })
//     } catch (err) {
//         console.log(`Fatal Error In Media Model findMedia: ${err}`)
//         throw err
//     }
// }
  