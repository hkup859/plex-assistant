// const timestamps = require('mongoose-timestamp');
// const uuid = require('uuid')
const mongoose = require('mongoose')
const timestamps = require('mongoose-timestamp')

const MediaSchema = new mongoose.Schema({
    title: {
        type: String,
        required: false, // True if there is no error?
    },
    year: {
        type: String,
        required: false, // True if there is no error?
    },
    length: {
        type: String,
        required: false, // True if there is no error?
    },
    description: {
        type: String,
        required: false, // True if there is no error?
    },
    genres: {
        type: [String],
        required: false, // True if there is no error?
    },
    resolution: {
        type: String,
        required: false, // True if there is no error?
    },
    airData: {
        date: {
            type: Date,
            required: false, // True if there is no error?
        },
        network: {
            type: String,
            required: false, // True if there is no error?
        },
    },
    posterImage: {
        type: mongoose.Schema.Types.Mixed, // TODO - update once implemented
        required: false, // True if there is no error?
    },
    extraDatas: {
        type: mongoose.Schema.Types.Mixed,
        required: false,
    },
    rawData: {
        type: String,
        required: true,
        unique: true
    },
    error: {
        type: Boolean,
        required: true,
        default: false
    },
    mediaType: {
        type: String,
        required: true,
        enum: ['Movies', 'TV Shows'] // This is the terminology that Plex uses, but I would like to change to "Movie" & "TV Show", this however causes issues with some puppeteer sections that also use mediaType because they need exactly what Plex calls it.
    },
    // createdAt & updatedAt are automatically generated by the timestamps plugin
})


// MediaSchema.pre('validate', function (callback) {
//     console.log('Pre validating request...');
//     if (!this.entityKey) {
//         this.entityKey = uuid.v4();
//     }
//     if(callback)
//     {
//         return callback()
//     }
//     else
//     {
//         return true
//     }
// });

// createdAt & updatedAt are automatically generated by the timestamps plugin
MediaSchema.plugin(timestamps);

// Create mongoose connection
const Media = mongoose.connection.model('Media', MediaSchema);

// MediaSchema.statics.createMedia = async function (mediaObject) {
export const createMedia = async (mediaObject): Promise<any> => {
  try {
        console.log('In Media Model createMedia')
        const media = new Media(mediaObject)
        const newMedia = await media.save()
        if (newMedia && newMedia._id)
            return newMedia
        else
            throw new Error("Failed to create media record. No _id after attempting to save.")
  } catch (err) {
        console.log(`Fatal Error In Media Model createMedia: ${err}`)
        throw err
  }
}

// TODO - Should this instead use save() so that timestamps work automatically? This adds inefficiency becase a find is required, but add timestamp simplicity.
export const updateMedia = async (_id, mediaUpdateObject): Promise<any> => {
    try {
        console.log('In Media Model updateMedia')
        const updateQuery = {
            $set: {
                updatedAt: new Date(),
                ...mediaUpdateObject
            }
        }
        console.log("-----------------------------")
        console.log("mediaUpdateObject: ", mediaUpdateObject)
        console.log("updateQuery: ", updateQuery)
        console.log("-----------------------------")
        const updateResults = await Media.updateOne({_id }, updateQuery)
        if (updateResults) // TODO - Provide optional return of the saved media object?
            return "success"
        else
            throw new Error("Failed to update media record. ...")
    } catch (err) {
        console.log(`Fatal Error In Media Model updateMedia: ${err}`)
        throw err
    }
}

// TODO - Split into more detailed find operations once use cases are established
export const findMedia = async (searchCriteria): Promise<any> => {
    try {
        console.log('In Media Model findMedia')
        return await Media.find(searchCriteria)
    } catch (err) {
        console.log(`Fatal Error In Media Model findMedia: ${err}`)
        throw err
    }
}

// TODO - Should this take into account records that are missing some data, like if genre failed? Or would that just cause re-processing the same errors over and over? Perhaps a separate route to run if logic is changed?
export const findAllUnprocessedMedia = async (): Promise<any> => {
    try {
        console.log('In Media Model findAllUnprocessedMedia')
        return await Media.find({ rawData: { $exists: true }, error: false, title: { $exists: false }, year: { $exists: false }, length: { $exists: false }}) // TODO, add other fields & perhaps reprocess errors a certain number of times
    } catch (err) {
        console.log(`Fatal Error In Media Model findMedia: ${err}`)
        throw err
    }
}

export const testMedia = async (): Promise<any> => {
    try {
        console.log('In Media Model findAllUnprocessedMedia')
        return await Media.find({ title: 'Larceny in Her Heart' })
    } catch (err) {
        console.log(`Fatal Error In Media Model findMedia: ${err}`)
        throw err
    }
}
  