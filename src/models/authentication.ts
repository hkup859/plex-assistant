// const timestamps = require('mongoose-timestamp');
// const uuid = require('uuid')
const mongoose = require('mongoose')
const timestamps = require('mongoose-timestamp')

const AuthenticationSchema = new mongoose.Schema({
    title: {
        type: String,
        required: true,
    },
    year: {
        type: String,
        required: false, // TODO - Require if movie?, TV Shows will not have this
    },
    // resolution: { // Should this be the resolution we have or the resolution we look for? Meaning, we could just track the best resolution and always record a better one, or we could simply require a certain resolution. I lean more towards tracking current and getting what we can.
    //     type: String,
    //     required: false,
    // },
    mediaType: {
        type: String,
        required: true,
        enum: ['Movies', 'TV Shows'] // This is the terminology that Plex uses, but I would like to change to "Movie" & "TV Show", this however causes issues with some puppeteer sections that also use mediaType because they need exactly what Plex calls it.
    },
    shouldRecord: { // TODO - Set this to false when something is marked as recorded or detected as already being recorded
        type: Boolean,
        required: true,
    },
    lastAired: {
        type: Date,
        required: false // Optional field that allows tracking when the last instance of this media was aired (TV Show will need to choose the last episode instead of first)
    }
    // createdAt & updatedAt are automatically generated by the timestamps plugin
    // TODO - Add complex key -> title alone cannot be unique, but perhaps title with year if available or title with mediaType?
})

// createdAt & updatedAt are automatically generated by the timestamps plugin
AuthenticationSchema.plugin(timestamps);

// Create mongoose connection
const Authentication = mongoose.connection.model('Authentication', AuthenticationSchema);

export const createAuthentication = async (authenticationObject: any): Promise<any> => {
  try {
        console.log('In Authentication Model createAuthentication')
        const authentication = new Authentication(authenticationObject)
        const newAuthentication = await authentication.save()
        if (newAuthentication && newAuthentication._id)
            return newAuthentication
        else
            throw new Error("Failed to create authentication record. No _id after attempting to save.")
  } catch (err) {
        console.log(`Fatal Error In Authentication Model createAuthentication: ${err}`)
        throw err
  }
}

// TODO - Should this instead use save() so that timestamps work automatically? This adds inefficiency becase a find is required, but add timestamp simplicity.
// TODO - Should add api authentication and track who made the update
// export const updateAuthentication = async (_id, priorityUpdateObject): Promise<any> => {
//     try {
//         console.log('In Authentication Model updateAuthentication')
//         const updateQuery = {
//             $set: {
//                 updatedAt: new Date(),
//                 ...priorityUpdateObject
//             }
//         }
//         const updateResults = await Authentication.updateOne({_id }, updateQuery)
//         if (updateResults) // TODO - Provide optional return of the saved media object?
//             return "success"
//         else
//             throw new Error("Failed to update priority record.")
//     } catch (err) {
//         console.log(`Fatal Error In Authentication Model updateAuthentication: ${err}`)
//         throw err
//     }
// }

export const findAuthenticationByEmail = async (encryptedEmail: string): Promise<any> => {
    try {
        console.log('In Authentication Model findAuthenticationByTitleAndAuthenticationType')
        return await Authentication.find({ email: encryptedEmail })
    } catch (err) {
        console.log(`Fatal Error In Authentication Model findAuthenticationByTitleAndAuthenticationType: ${err}`)
        throw err
    }
}